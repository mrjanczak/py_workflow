! select nodes to map parent components to
! map child component elements to parent component elements based on proximity

! CM_NAME_PFX = ARG1 ! name prefix of the component
! TOLER = ARG2     ! tolerance for mapping

*go,:lib
:start

resume


esel,s,mat,,1
nsle
nsel,r,ext

_util_get_parent_cms,'PARENT_DATA_','bsur000',1,4

!_util_map_parent_cms,'PARENT_DATA_','bsur000',1,4,.002,15

esel,s,ename,,200
nsle
/PNUM,REAL,1
eplo

/eof
! ---------------------------------
! Create macros to get parent component data and map child elements
! ---------------------------------
*create,_util_get_parent_cms,mac
    ! desc: Get parent component data and create parent elements

    ! notes: Array FACES_DATA contains data of pairs of adjacent faces attached to common node:
    ! N0x,N0y, CM1,N1x,N1y, CM2,N2x,N2y
    !
    ! ```
    !   CM1    CM2       CM1        CM2
    ! x-----o-----x  , x-----o  , o-----x 
    ! N1    N0    N2   N1    N0   N0    N2
    ! ```

    CM_PATTERN =   ARG1 ! component name pattern, e.g. 'bsur000'
    CM0 =          ARG2 ! first component index
    CM1 =          ARG3 ! last component index
    DATA_FILE =    ARG4 ! name of the array to store parent component data

    ! Default values
    *get,DATA_FILE_TYPE,PARM, DATA_FILE,TYPE
    *if,DATA_FILE_TYPE,eq,0,then
        DATA_FILE = CM_PATTERN
    *endif

    ! Create parent elements 200 with real = component index
    *get,ET_MAX,ETYP,,NUM,MAX
    PARENT_ET = ET_MAX+1

    *del,CM_DATA_,,nopr $ *dim,CM_DATA_,array,CM1,5 ! parent columns: 1=count, 2=length, child columns: 3=count, 4=length, 5 ratio
    *do,CMi,CM0,CM1
        CM_NAME = CM_PATTERN
        *if,CMi,gt,0,then
            CMi_s = CHRVAL(CMi)
            CM_NAME = STRFILL(CM_NAME, CMi_s, STRLENG(CM_NAME)-STRLENG(CMi_s)+1) 
        *endif
        *get,CM_TYPE,COMP,CM_NAME,TYPE
        *if,CM_TYPE,ne,1,then
            *msg,ERROR, 'Component %CM_NAME% does not exist or is not nodal'
            %C
            *cycle
        *endif

        cmsel,s,CM_NAME
        esln
        *get,ET_MAX,ETYP,,NUM,MAX
        et,PARENT_ET,MESH200
        type,PARENT_ET
        real, CMi
        esurf

        ! count and measure length of parent component elements
        esel,s,type,,PARENT_ET
        esel,r,real,,CMi 
        *VGET, CM_SEL_, ELEM, ,NSEL
        *VMASK,CM_SEL_ $ *VGET, CM_LEN_, ELEM, ,GEOM
        *VMASK,CM_SEL_ $ *VSCFUN,CM_COUNT, SUM, CM_SEL_(1)
        *VMASK,CM_SEL_ $ *VSCFUN,CM_LEN_SUM, SUM, CM_LEN_(1)
        CM_DATA_(CMi,1) = CM_COUNT   
        CM_DATA_(CMi,2) = CM_LEN_SUM
    *ENDDO
    *VSCFUN,TOTAL_CM_COUNT, SUM, CM_DATA_(1,1)
    *VSCFUN,TOTAL_CM_LEN,   SUM, CM_DATA_(1,2)

    ! Check if components do not overlap
    esel,s,type,,PARENT_ET
    *VGET, ET_SEL_, ELEM, ,NSEL
    *VMASK,ET_SEL_ $ *VGET,  ET_LEN_, ELEM, ,GEOM
    *VMASK,ET_SEL_ $ *VSCFUN,ET_COUNT, SUM, ET_SEL_(1)
    *VMASK,ET_SEL_ $ *VSCFUN,ET_LEN_SUM, SUM, ET_LEN_(1)

    *if,ET_COUNT,ne,TOTAL_CM_COUNT, and, ET_LEN_SUM,gt,0, then
        LEN_RATIO = (TOTAL_CM_LEN-ET_LEN_SUM) / ET_LEN_SUM
        *msg,WARNING, TOTAL_CM_COUNT-ET_COUNT, LEN_RATIO
        %I elements overlaps between components (overlaping length ratio %E). 
    *endif

    ! Get parent elements attached to each node
    nsle
    *get,N_COUNT,NODE,,COUNT
    *del,FACES_DATA_,,nopr $ *dim,FACES_DATA_,array,N_COUNT,8
    *del,N0_,,nopr $ *dim,N0_,array,N_COUNT
    !  N0x,N0y, CM1,N1x,N1y, CM2,N2x,N2y
    *VGET, N0_(1), NODE, ,NLIST
    *do,Ni,1,N_COUNT
        N0 = N0_(Ni)
        FACES_DATA_(Ni,1) = NX(N0)
        FACES_DATA_(Ni,2) = NY(N0)
        
        *del,E_,,nopr $ *dim,E_,array,2
        *del,N_,,nopr $ *dim,N_,array,2,2
        *do,LOCi,1,2
            E2 = ENEXTN(N0,LOCi)
            *if,E2,eq,0,cycle
            E2_N1 = NELEM(E2,1)
            E2_N2 = NELEM(E2,2)
            *if,E2_N1,eq,N0,then
                E2_N1 = E2_N2
            *endif        
            FACES_DATA_(Ni,2+(LOCi-1)*3+1) = EATT(E2, 3)
            FACES_DATA_(Ni,2+(LOCi-1)*3+2) = NX(E2_N1)
            FACES_DATA_(Ni,2+(LOCi-1)*3+3) = NY(E2_N1)
        *enddo
    *enddo

    esel,s,type,,PARENT_ET
    edele,all
    *cfopen,'%DATA_FILE%',inp
    *vwrite,FACES_DATA_(1,1),FACES_DATA_(1,2),FACES_DATA_(1,3),FACES_DATA_(1,4),FACES_DATA_(1,5),FACES_DATA_(1,6),FACES_DATA_(1,7),FACES_DATA_(1,8)
(8E8.3)
    *cfclos
    *cfopen,'%DATA_FILE%_CM',inp
    *vwrite,CM_DATA_(1,1),CM_DATA_(1,2),0,0,0
(5E8.3)
    *cfclos    
*end

*create,_util_map_parent_cms,mac
    ! desc: Map parent components on child elements

    CM_PATTERN =      ARG1 ! component name pattern, e.g. 'bsur000'
    CM0 =             ARG2 ! first component index
    CM1 =             ARG3 ! last component index
    DATA_FILE =       ARG4 ! name of the array to store parent component data
    TOLER =           ARG5 ! tolerance of mapping
    NORM_DEV =        ARG6 ! maximum normal deviation in degrees
    ITER_MAX =        ARG7 ! maximum number of iterations to assign parent components
    EXCLUDE_CM =      ARG8 ! name of nodal component with region excluded from mapping

    /PREP7
    *afun,deg

    ! Default values
    *get,DATA_FILE_TYPE,PARM, DATA_FILE,TYPE
    *if,DATA_FILE_TYPE,eq,0,then
        DATA_FILE = CM_PATTERN
    *endif
    *if,TOLER,eq,0,then
        TOLER = 1e-3
    *endif
    *if,NORM_DEV,eq,0,then
        NORM_DEV = 15
    *endif
    *if,ITER_MAX,eq,0,then
        ITER_MAX = 3
    *endif
    *get,EXCLUDE_CM_TYPE,PARM, EXCLUDE_CM,TYPE

    ! Read parent data
    /INQUIRE,DATA_EXIST,EXIST,   '%DATA_FILE%',inp
    /INQUIRE,CM_DATA_EXIST,EXIST,'%DATA_FILE%_CM',inp
    *if,DATA_EXIST*CM_DATA_EXIST,eq,0,then
        *msg,ERRROR, _PARENT_DATA
        %C Parent data %DATA_FILE% or %DATA_FILE%_CM does not exist. Run _util_get_parent_cms first.
    *endif
    /INQUIRE,PARENT_N_COUNT,SIZE,'%DATA_FILE%',inp
    *del,FACES_DATA_,,nopr $ *dim,FACES_DATA_,array,PARENT_N_COUNT,8
    *vread,FACES_DATA_(1,1),'%DATA_FILE%',inp,,jik,8,PARENT_N_COUNT
(8E8.3)    
    /INQUIRE,N_COUNT,SIZE,'%DATA_FILE%_CM',inp
    *del,CM_DATA_,,nopr $ *dim,CM_DATA_,array,N_COUNT,5
    *vread,CM_DATA_(1,1), '%DATA_FILE%_CM',inp,,jik,5,N_COUNT
(5E8.3) 

    ! Create parent nodes based on parent component data
    *get,PARENT_N_OFF,NODE,,NUM,MAX
    *do,Ni,1,PARENT_N_COUNT
        N0x = FACES_DATA_(Ni,1)
        N0y = FACES_DATA_(Ni,2)
        N,Ni+PARENT_N_OFF,N0x,N0y
    *enddo

    ! Create child elements 200 based on selected nodes
    *get,ET_MAX,ETYP,,NUM,MAX
    CHILD_ET = ET_MAX+1
    ESLN
    et,CHILD_ET,MESH200
    type,CHILD_ET
    real,CM1+1
    esurf

    esel,s,type,,CHILD_ET
    *get,E_COUNT,ELEM,,COUNT
    *del,CHILD_E_,,nopr $ *dim,CHILD_E_,array,E_COUNT,8
    *vget,CHILD_E_(1,1), ELEM, , ELIST
    *do,Ei,1,E_COUNT
        E1 = CHILD_E_(Ei,1)
        CHILD_E_(Ei,2) = CENTRX(E1)
        CHILD_E_(Ei,3) = CENTRY(E1)
        CHILD_E_(Ei,4) = 0
        N1 = NELEM(E1,1)
        N2 = NELEM(E1,2)
        CHILD_E_(Ei,5) = NX(N2)-NX(N1)
        CHILD_E_(Ei,6) = NY(N2)-NY(N1)        
    *enddo

    ! Map child elements to parent elements
    esel,s,TYPE,,PARENT_ET
    nsle
    *MOPER, CHILD_E_(1,7), CHILD_E_(1,2), NNEAR, TOLER
    *do,Ei,1,E_COUNT
        ! Child element E1
        E1 =  CHILD_E_(Ei,1)
        E1x = CHILD_E_(Ei,2)
        E1y = CHILD_E_(Ei,3)
        v00x = CHILD_E_(Ei,5)
        v00y = CHILD_E_(Ei,6)

        ! Get nearest parent node
        N1 = CHILD_E_(Ei,7)
        *if,N1,eq,0,cycle

        Ni = N1 - PARENT_N_OFF
        N1x = FACES_DATA_(Ni,1)
        N1y = FACES_DATA_(Ni,2)

        ! Get parent elemets attached to this node
        norm_dev_1 = 1e3
        norm_dev_2 = 1e3
        *do,LOCi,1,2
            PARENT_CMi = FACES_DATA_(Ni,2+(LOCi-1)*3+1)
            *if,PARENT_CMi,eq,0,cycle

            N2x = FACES_DATA_(Ni,2+(LOCi-1)*3+2)
            N2y = FACES_DATA_(Ni,2+(LOCi-1)*3+3)

            v0x = N2x - N1x
            v0y = N2y - N1y
            v1x = E1x - N1x
            v1y = E1y - N1y
            v2x = E1x - N2x
            v2y = E1y - N2y

            cross0 = v0x*v00y-v0y*v00x    
            dot0 =   v0x*v00x+v0y*v00y     
            alf0 = abs(atan2(cross0, dot0))

            cross1 = v0x*v1y-v0y*v1x    
            dot1 =   v0x*v1x+v0y*v1y     
            alf1 = abs(atan2(cross1, dot1))

            cross2 = v0x*v2y-v0y*v2x    
            dot2 =   v0x*v2x+v0y*v2y     
            alf2 = abs(atan2(cross2, dot2))

            ! Check if projection falls within the parent element
            *if,alf1,le,90,and,alf2,ge,90,then
                is_inside = 1
            *else
                is_inside = 0
            *endif
            norm_dev_%LOCi% = alf0
            *if,alf0,le,norm_dev, and, is_inside,eq,1,then
                ! map child element to parent element
                CHILD_E_(Ei,8) = PARENT_CMi
                *exit          
            *endif
        *enddo

        ! If child outside both parent elems, use one with smallest deviation
        *if,CHILD_E_(Ei,6),eq,0,then

            *if, norm_dev_1, lt, norm_dev_2, and, norm_dev_1, le, norm_dev, then
                LOCi = 1                
            *elseif, norm_dev_2, lt, norm_dev_1, and, norm_dev_2, le, norm_dev, then
                LOCi = 2
            *endif
            CHILD_E_(Ei,8) = FACES_DATA_(Ni,2+(LOCi-1)*3+1)
        *endif
    *enddo

    ! Assign parent component to child elements
    esel,s,TYPE,,CHILD_ET
    *do,Ei,1,E_COUNT
        E1 = CHILD_E_(Ei,1)
        PARENT_CMi = CHILD_E_(Ei,8)
        *if,PARENT_CMi,gt,0,then
            emodif,E1,REAL, PARENT_CMi
        *endif
    *enddo

    ! If not mapped, get component from adjacent element
    COUNTER0 = 0
    COUNTER1 = 0
    *do,ITERi,1,ITER_MAX
        *do,Ei,1,E_COUNT
            PARENT_CMi = CHILD_E_(Ei,8)
            *if,PARENT_CMi,gt,0,CYCLE

            COUNTER1 = COUNTER1 + 1
            E1 = CHILD_E_(Ei,1)
            v00x = CHILD_E_(Ei,5)
            v00y = CHILD_E_(Ei,6)

            *do,LOCi,1,2
                N1 = NELEM(E1,LOCi)
                E2 = ENEXTN(N1,1)
                *if,E2,eq,E1,then
                    E2 = ENEXTN(N1,2)
                *endif
                *if,E2,eq,0,cycle
                N1 = NELEM(E1,1)
                N2 = NELEM(E1,2)
                v0x = NX(N2)-NX(N1)
                v0y = NY(N2)-NY(N1)   

                ! Check deviation
                cross0 = v0x*v00y-v0y*v00x    
                dot0 =   v0x*v00x+v0y*v00y     
                alf0 = abs(atan2(cross0, dot0)) 
                *if,alf0,lt,norm_dev,then
                    PARENT_CMi = EATT(E2,3)
                    emodif,E1,REAL, PARENT_CMi
                    *exit                            
                *endif
            *enddo
        *enddo   
        *if,COUNTER1,eq,COUNTER0,exit
        COUNTER0 = COUNTER1
        COUNTER1 = 0
    *enddo 

    ! Create child components
    *do,CMi,CM0,CM1
        CM_NAME = CM_PATTERN
        *if,CMi,gt,0,then
            CMi_s = CHRVAL(CMi)
            CM_NAME = STRFILL(CM_NAME, CMi_s, STRLENG(CM_NAME)-STRLENG(CMi_s)+1) 
        *endif
        esel,s,TYPE,,CHILD_ET
        esel,r,REAL,,CMi
        *if,EXCLUDE_CM_TYPE,ne,0,then
            cmsel,s,EXCLUDE_CM
            esln,u
        *endif
        nsle
        cm,CM_NAME,node

        *VGET, CM_SEL_, ELEM, ,NSEL
        *VMASK,CM_SEL_ $ *VGET, CM_LEN_, ELEM, ,GEOM
        *VMASK,CM_SEL_ $ *VSCFUN,CM_COUNT, SUM, CM_SEL_(1)
        *VMASK,CM_SEL_ $ *VSCFUN,CM_LEN_SUM, SUM, CM_LEN_(1)
        PAR_CM_COUNT =   CM_DATA_(CMi,1)
        PAR_CM_LEN_SUM = CM_DATA_(CMi,2)
        CM_LEN_RATIO =   0
       *if,PAR_CM_LEN_SUM,gt,TOLER,then
            CM_LEN_RATIO = CM_LEN_SUM / PAR_CM_LEN_SUM
        *endif
        CM_DATA_(CMi,3) = CM_COUNT   
        CM_DATA_(CMi,4) = CM_LEN_SUM
        CM_DATA_(CMi,5) = CM_LEN_RATIO
        *vwrite, CM_NAME, PAR_CM_LEN_SUM, CM_LEN_SUM, CM_LEN_RATIO
        Component %s: Parent length=%E, Child length=%E, Length ratio=%E
     *ENDDO
    *VSCFUN,PARENT_CM_LEN,   SUM, CM_DATA_(1,2)
    *VSCFUN,CHILD_CM_LEN,    SUM, CM_DATA_(1,4)
    TOTAL_LEN_RATIO = CHILD_CM_LEN / PARENT_CM_LEN
    *vwrite, PARENT_CM_LEN, CHILD_CM_LEN, TOTAL_LEN_RATIO
    ------------------------------------------ %/&
    Total parent component length=%E, Total child component length=%E, Length ratio=%E

    ! Check effectivness of mapping
    esel,s,TYPE,,CHILD_ET
    *VGET, ET_SEL_, ELEM, ,NSEL
    *VMASK,ET_SEL_ $ *VGET,  ET_LEN_, ELEM, ,GEOM
    *VMASK,ET_SEL_ $ *VSCFUN,ET_COUNT, SUM, ET_SEL_(1)
    *VMASK,ET_SEL_ $ *VSCFUN,ET_LEN_SUM, SUM, ET_LEN_(1)

    nsel,s,,,PARENT_N_OFF+1,PARENT_N_OFF+PARENT_N_COUNT
    ndele,all
    esel,s,TYPE,,CHILD_ET
    edele,all
*end

*go,:start
